<html>
    <head>
        <meta charset="utf-8">
        <title>Теория: понятие рекурсии</title>
        <link rel="stylesheet" href="css/myStyle.css" type="text/css">
    </head>
    <body>
        <div id="navigation">
            <ul>
                <li><a href="theory1.html">Теория</a></li>
                <li><a href="illustration1.html">Иллюстрация</a></li>
                <li><a href="test.php">Тест</a></li>
            </ul>
        </div>
        
        <div class="sidebar">
            <ul>
                <li><a href="theory1.html" class="special">Понятие рекурсии</a></li>
                <li><a href="theory2.html">Косвенная рекурсия</a></li>
                <li><a href="theory3.html">Рекурсия и итерация</a></li>
                <li>Примеры</li>
                <ul class="ex">
                    <li><a href="theory41.html">“Индийский алгоритм” возведения в степень</a></li>
                    <li><a href="theory42.html">Ханойские башни</a></li>
                    <li><a href="theory43.html">Обход графа в глубину</a></li>
                </ul>
            </ul>
        </div>
        
        <div id="page">
            <br><h1>Понятие рекурсии</h1><br>
            <div class="leftfoto">
                <img src="img/uroboros.png" alt="">
                <figcaption>Образное представление рекурсии. Уроборос – змей, пожирающий свой хвост</figcaption>
            </div>
            <p>
                Рекурсия — это определение, описание, изображение какого-либо объекта или процесса внутри самого этого объекта или процесса, то есть ситуация, когда объект является частью самого себя.</p><p>
В программировании рекурсия — вызов функции (процедуры) из неё же самой, непосредственно (простая рекурсия) или через другие функции (косвенная или сложная рекурсия). </p><p>
С помощью конечной рекурсивной программы можно описать бесконечное вычисление, причем программа не будет содержать явных повторений. Однако рекурсивные алгоритмы лучше всего использовать, если в решаемой задаче, вычисляемой функции или структуре обрабатываемых данных рекурсия уже присутствует явно. В общем виде рекурсивную программу P можно выразить как некоторую композицию P из множества операторов S (не содержащих P) и самой P: </p><p>
P = P[S,P]
</p><p> 
Для выражения рекурсивных программ необходимо и достаточно иметь понятие процедуры  или подпрограммы, поскольку они позволяют дать любому оператору имя, с помощью которого к нему можно обращаться. Если некоторая процедура P содержит явную ссылку на саму себя, то ее называют прямо рекурсивной, если же P ссылается на другую процедуру Q, содержащую ссылку на P, то P называют косвенно рекурсивной. Поэтому по тексту программы рекурсивность не всегда определима.</p><p> 
В рекурсивном определении не должно быть “заколдованного круга”, когда объект определяется с помощью себя самого или с помощью других, но заданных через него же. Чтобы подобная бесконечность не возникала в рекурсивном определении, должны выполняться следующие условия:</p>
<ol>
    <li>Множество определяемых объектов является частично упорядоченным.</li>
    <li>Каждая убывающая по этому упорядочению последовательность элементов заканчивается некоторым минимальным элементом.</li>
    <li>Минимальные элементы определяются нерекурсивно.</li>
    <li>Неминимальные элементы определяются с помощью элементов, которые меньше их по этому упорядочению.</li>
</ol><p>
С рекурсивными подпрограммами связаны два важных понятия – глубина рекурсии и общее количество вызовов, порожденных вызовом рекурсивной подпрограммы. Глубина рекурсии – максимальное количество незаконченных рекурсивных вызовов при выполнении её вызова. При выполнении вызова с глубиной рекурсии t одновременно существует t экземпляров локальной памяти. Каждый экземпляр имеет определённый размер, и если глубина будет чересчур большой, то автоматической памяти, предоставленной процессу выполнения программы, может не хватить. </p><p>
Рассмотрим пример простейшей рекурсивной процедуры на языке Pascal:</p><pre>
procedure RecProc(a: integer);
begin
  if a>0 then
    RecProc(a-1);
  writeln(a);
end;
</pre><p>
Процедура RecProc вызывается с параметром a = n. В ней содержится вызов процедуры RecProc с параметром a = n-1. Предыдущий вызов еще не завершился, поэтому создается еще одна процедура и до окончания ее работы первая свою работу не заканчивает. И только когда новый экземпляр завершит работу (вернет вычисленные результаты), будет продолжена работа исходной процедуры. Информация о таких незавершенных вызовах рекурсивных подпрограмм (а это, в самом простом представлении, значения переменных, необходимых для работы подпрограммы) запоминается в стеке. Процесс вызова заканчивается, когда параметр a = 0. В этот момент одновременно выполняются n+1 экземпляров процедуры. Таким образом, глубина рекурсии равна n+1. Последняя вызванная процедура (RecProc(0)) напечатает число 0 и закончит свою работу. После этого управление возвращается к процедуре, которая ее вызвала (Rec(1)) и печатается число 1. И так далее, пока не завершатся все процедуры. Результатом исходного вызова будет вывод чисел: 0, 1, 2, …, n.</p><p>
Заметим, что в приведенном примере рекурсивный вызов стоит внутри условного оператора. Это необходимое условие для того, чтобы рекурсия когда-нибудь закончилась. Также заметим, что сама себя процедура вызывает с другим параметром, не таким, с каким была вызвана она сама. Если в процедуре не используются глобальные переменные, то это также необходимо, чтобы рекурсия не продолжалась до бесконечности.

            </p>
        </div>
        <script>
            alert("Добро пожаловать в MyRecursionTraining!");
        </script>
    </body>
</html>