<html>
    <head>
        <meta charset="utf-8">
        <title>Теория: рекурсия и итерация</title>
        <link rel="stylesheet" href="css/myStyle.css" type="text/css">
    </head>
    <body>
        <div id="navigation">
            <ul>
                <li><a href="theory1.html">Теория</a></li>
                <li><a href="illustration1.html">Иллюстрация</a></li>
                <li><a href="test.php">Тест</a></li>
            </ul>
        </div>
        
        <div class="sidebar">
            <ul>
                <li><a href="theory1.html">Понятие рекурсии</a></li>
                <li><a href="theory2.html">Косвенная рекурсия</a></li>
                <li><a href="theory3.html" class="special">Рекурсия и итерация</a></li>
                <li>Примеры</li>
                <ul class="ex">
                    <li><a href="theory41.html">“Индийский алгоритм” возведения в степень</a></li>
                    <li><a href="theory42.html">Ханойские башни</a></li>
                    <li><a href="theory43.html">Обход графа в глубину</a></li>
                </ul>
            </ul>
        </div>
        
        <div id="page">
            <br><h1>Рекурсия и итерация</h1><br>
            <p>
               Рекурсивные алгоритмы наиболее пригодны в случаях, когда поставленная задача или используемые данные определены рекурсивно. Но это не значит, что при наличии таких рекурсивных определений лучшим способом решения задачи непременно является рекурсивный алгоритм.</p><p>
Программы, в которых следует избегать использования рекурсии, можно охарактеризовать следующими схемами, изображающими их строение:</p><p>
 P ≡ if B then (S; P)</p><p>
 P ≡ (S; if B then P)</p><p>
Эти схемы естественно применять в тех случаях, когда вычисляемые значения определяются с помощью простых рекуррентных соотношений . Ярким примером таких случаев служит широко известная задача вычисления факториалов:</p><p>
n!=1∙2∙3∙…∙n</p><p>
Очередной факториал  n! можно вычислить по предыдущему как:</p><p>
n!=(n-1)!∙n</p><p><pre>
Рассмотрим рекурсивный алгоритм: 
function Factorial(n: integer): integer;
begin
  if n > 1 then
    Factorial := n * Factorial(n-1)
  else
    Factorial := 1;
end;</pre></p><p>
В данном примере очевидно, что рекурсию можно заменить обычной итерацией. Итерационный алгоритм будет выглядеть следующим образом:</p><p><pre>
function Factorial(n: integer): integer;
x := 1;
for i := 2 to n do
x := x * i;
  Factorial := x;
end;</pre></p><p>
Следует понимать, что вызов функций влечет за собой некоторые дополнительные накладные расходы, поэтому итерационные решения работают быстрее рекурсивных.</p><p>
Рассмотрим частный случай рекуррентных соотношений, когда следующее значение в последовательности зависит не от одного, а сразу от нескольких предыдущих значений. Примером может служить известная последовательность Фибоначчи, в которой каждый следующий элемент есть сумма двух предыдущих:</p><p>
x<sub>n</sub>=x<sub>n-1</sub>+x<sub>n-2</sub>,x<sub>0</sub>=1,x<sub>1</sub>=1</p><p>
Возможная рекурсивная реализация:</p><p><pre>
function Fib(n: integer): integer;
begin
  if n > 1 then
    Fib := Fib(n-1) + Fib(n-2)
  else
    Fib := 1;
end;</pre></p><p>
Каждый вызов Fib создает сразу две копии себя, каждая из копий – еще две и т.д. Количество операций растет с номером n экспоненциально, хотя при итерационном решении достаточно линейного по n количества операций. Дерево рекурсивных вызовов, например, для n=5 можно представить следующей схемой:</p><p>
<img src="img/SRC.png" alt="">
</p><p>
 
Приведенный пример показывает, как не следует использовать рекурсию. Но заметим, что если существует быстрое итерационное решение, то тот же цикл можно реализовать с помощью рекурсивной процедуры или функции. Например:</p><p><pre>
function Fib(x1, x2, n: integer): integer;
var
  x3: integer;
begin
  if n > 1 then
  begin
    x3 := x2 + x1;
    x1 := x2;
    x2 := x3;
    Fib := Fib(x1, x2, n-1);
  end else
    Fib := x2;
end;</pre></p><p>
Любые рекурсивные процедуры и функции, содержащие всего один рекурсивный вызов самих себя, легко заменяются итерационными циклами. Чтобы получить что-то, не имеющее простого нерекурсивного аналога, следует обратиться к процедурам и функциям, вызывающим себя два и более раз. В этом случае множество вызываемых процедур образует уже не цепочку, а целое дерево. Существуют широкие классы задач, когда вычислительный процесс должен быть организован именно таким образом. Как раз для них рекурсия будет наиболее простым и естественным способом решения.

            </p>
        </div>
        
    </body>
</html>