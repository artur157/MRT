<p><i><b>Деревом</b></i> будем называть конечное множество T, состоящее из одного или более узлов, таких что:</p>
<p>
   - Имеется один специальный узел, называемый <i><b>корнем</b></i> данного дерева.
<br>   - Остальные узлы (исключая корень) содержатся в m >= 0 попарно непересекающихся подмножествах T1, T2, …, Tm, каждое из которых в свою очередь является деревом. Деревья T1, T2, …, Tm называются <i><b>поддеревьями</b></i> данного дерева.
</p>
<p>Это определение является рекурсивным. Если коротко, то дерево это множество, состоящее из корня и присоединенных к нему поддеревьев, которые тоже являются деревьями. Дерево определяется через само себя. Однако данное определение осмысленно, так как рекурсия конечна. Каждое поддерево содержит меньше узлов, чем содержащее его дерево. В конце концов, мы приходим к поддеревьям, содержащим всего один узел. </p>
<br><img src="img/tree1.jpg" alt=""><br><br>
<p>Узлы, не содержащие поддеревьев, называются <i><b>концевыми узлами</b></i> или <i><b>листьями</b></i>. Множество непересекающихся деревьев называется <i><b>лесом</b></i>. Например, лес образуют поддеревья, исходящие из одного узла.</p>
<p>Если каждая вершина дерева имеет не более двух потомков, то такое дерево называется <i><b>бинарным</b></i> или <i><b>двоичным</b></i>.</p>
<p><h2>Обходы деревьев</h2></p>
<p>Во всех алгоритмах, связанных с древовидными структурами встречается одна и та же идея, а именно идея <i><b>прохождения</b></i> или <i><b>обхода</b></i> дерева. Это такой способ посещения узлов дерева, при котором каждый узел проходится точно один раз. При этом получается линейная расстановка узлов дерева. В частности существует три способа: можно проходить узлы в прямом, обратном и синтаксическом порядке. Будем рассматривать бинарные деревья.</p>
<p>Структуру бинарного дерева будем описывать следующим образом:</p>
<pre>

type ukaz = ^tree;
tree = record 
  mark: integer;
  left: ukaz;
  right: ukaz;
end;

</pre>
<p><h3>Прямой обход (префиксный, в глубину «сверху вниз»)</h3></p>
<p>Алгоритм:
<ol><li>Начать с корня дерева.</li>
<li>Пометить текущую вершину.</li>
<li>Совершить прямой обход левого поддерева.</li>
<li>Совершить прямой обход правого поддерева.</li></ol></p>
<p>Реализация:</p>
<pre>

procedure preorder(p: ukaz; k: integer);
begin 
  p^.mark:= k;
  if p^.left <> nil then preorder(p^.left, k+1);
  if p^.right <> nil then preorder(p^.right, k+1);
end;

begin
  ...
  preorder(root, 1);       {Вызов из тела программы}
  ...
end.
 
</pre>

<br><img src="img/tree2.jpg" alt=""><br><br>
<p><h3>Обратный обход (постфиксный, в глубину «снизу вверх»)</h3></p>
<p>Алгоритм:
<ol><li>Начать с корня дерева.</li>
<li>Совершить обратный обход левого поддерева.</li>
<li>Совершить обратный обход правого поддерева.</li>
<li>Пометить текущую вершину.</li></ol></p>
<pРеализация:</p>
<pre>

procedure postorder(p: ukaz; k: integer);
begin
  if p^.left <> nil then postorder(p^.left, k+1);
  if p^.right <> nil then postorder(p^.right, k+1)
  p^.mark:= k;
end;

begin
  ...
  postorder(root,1);       {Вызов из тела программы}
  ...
end.
 
</pre>
<br><img src="img/tree3.jpg" alt=""><br><br>
<p><h3>Синтаксический обход (инфиксный)</h3></p>
<p>Алгоритм:
<ol><li>Начать с корня дерева.</li>
<li>Совершить прямой обход левого поддерева.</li>
<li>Пометить текущую вершину.</li>
<li>Совершить прямой обход правого поддерева.</li></ol></p>
<p>Реализация:</p>
<pre>

procedure syntorder(p: ukaz; k: integer);
begin 
  if p^.left <> nil then syntorder(p^.left, k+1);
  p^.mark:= k;
  if p^.right <> nil then syntorder(p^.right, k+1);
end;

begin
  ...
  syntorder(root,1);       {Вызов из тела программы}
  ...
end.
 
</pre>
<br><img src="img/tree4.jpg" alt=""><br><br>
<p><h3>Обход в ширину</h3></p>
<p>Последовательность обхода:
<ol><li>Пометить вершину 0-го уровня (корень дерева).</li>
<li>Пометить все вершины 1-го уровня.</li>
<li>Пометить все вершины 2-го уровня.</li>
<li>...</li></ol></p>
<p>Алгоритм:
<ol><li>Занести в очередь корень дерева.</li>
<li>Пока очередь не станет пустой, повторять следующие действия.</li>
<li>Пометить и удалить первый элемент из головы очереди.</li>
<li>Добавить в хвост очереди всех потомков удаленной вершины.</li></ol></p>
<p>Реализация:</p>
<p>Для простоты реализации пополним структуру дерева полем next: ukaz, которое будет служить для связки очереди.</p>
<pre>

procedure BFS(root: ukaz);
var head, tail: ukaz;
k: integer;
begin
  head:= root;
  tail:= root;
  k:= 0;
  repeat
    tail^.next:= head^.left;
    if head^.left <> nil then tail:= tail^.next;
    tail^.next:= head^.right;
    if head^.right <> nil then tail:= tail^.next;
    inc(k);
    head^.mark:= k;	
    head:= head^.next
  until head = nil;
end;

begin
  ...
  BFS(root);       {Вызов из тела программы}
  ...
end.
 
</pre>
<br><img src="img/tree5.jpg" alt=""><br><br>
<p><h3>Двоичное дерево поиска</h3></p>
<p><i><b>Двоичное дерево поиска</b></i> для множества чисел S - это размеченное бинарное дерево, каждой вершине которого сопоставлено число из множества S, причем все пометки удовлетворяют следующим условиям:
<ol><li>Существует ровно одна вершина, помеченная любым числом из множества S.</li>
<li>Все пометки левого поддерева строго меньше, чем пометка текущей вершины.</li>
<li>Все пометки правого поддерева строго больше, чем пометка текущей вершины.</li></ol></p>
<p>Если выражаться простым языком, то структура дерева двоичного поиска подчиняется простому правилу: «если больше - направо, если меньше – налево».</p>
<p>Например, для набора чисел 7, 3, 5, 2, 8, 1, 6, 10, 9, 4, 11 получится такое дерево</p>
<br><img src="img/tree6.jpg" alt=""><br><br>
<p>Для того чтобы правильно учесть повторения чисел, можно ввести дополнительное поле, которое будет хранить количество вхождений для каждого числа.</p>
<p>С помощью двоичного дерева поиска можно организовать эффективный способ поиска, который значительно эффективнее поиска по списку.</p>
<p>Поиск в упорядоченном дереве выполняется по следующему рекурсивному алгоритму: если дерево пусто, то искомый элемент не найден, иначе сравнить искомый ключ с ключом в корне дерева: 
<br>– если ключи совпадают, поиск завершен; 
<br>– если ключ в корне больше искомого, выполнить поиск в левом поддереве; 
<br>– если ключ в корне меньше искомого, выполнить поиск в правом поддереве. <p>


