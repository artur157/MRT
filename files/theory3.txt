<p>
               Рекурсивные алгоритмы наиболее пригодны в случаях, когда поставленная задача или используемые данные определены рекурсивно. Но это не значит, что при наличии таких рекурсивных определений лучшим способом решения задачи непременно является рекурсивный алгоритм.</p><p>
Программы, в которых следует избегать использования рекурсии, можно охарактеризовать следующими схемами, изображающими их строение:</p><p>
 P = if B then (S; P)</p><p>
 P = (S; if B then P)</p><p>
Эти схемы естественно применять в тех случаях, когда вычисляемые значения определяются с помощью простых рекуррентных соотношений . Ярким примером таких случаев служит широко известная задача вычисления факториалов:</p><p>
n!=1•2•3•…•n</p><p>
Очередной факториал  n! можно вычислить по предыдущему как:</p><p>
n!=(n-1)!•n</p><p>
Рассмотрим рекурсивный алгоритм: <pre>
function Factorial(n: integer): integer;
begin
  if n > 1 then
    Factorial := n * Factorial(n-1)
  else
    Factorial := 1;
end;</pre></p><p>
В данном примере очевидно, что рекурсию можно заменить обычной итерацией. Итерационный алгоритм будет выглядеть следующим образом:</p><p><pre>
function Factorial(n: integer): integer;
x := 1;
for i := 2 to n do
x := x * i;
  Factorial := x;
end;</pre></p><p>
Следует понимать, что вызов функций влечет за собой некоторые дополнительные накладные расходы, поэтому итерационные решения работают быстрее рекурсивных.</p><p>
Рассмотрим частный случай рекуррентных соотношений, когда следующее значение в последовательности зависит не от одного, а сразу от нескольких предыдущих значений. Примером может служить известная последовательность Фибоначчи, в которой каждый следующий элемент есть сумма двух предыдущих:</p><p>
x<sub>n</sub>=x<sub>n-1</sub>+x<sub>n-2</sub>,x<sub>0</sub>=1,x<sub>1</sub>=1</p><p>
Возможная рекурсивная реализация:</p><p><pre>
function Fib(n: integer): integer;
begin
  if n > 1 then
    Fib := Fib(n-1) + Fib(n-2)
  else
    Fib := 1;
end;</pre></p><p>
Каждый вызов Fib создает сразу две копии себя, каждая из копий – еще две и т.д. Количество операций растет с номером n экспоненциально, хотя при итерационном решении достаточно линейного по n количества операций. Дерево рекурсивных вызовов, например, для n=5 можно представить следующей схемой:</p><p>
<img src="img/SRC.png" alt="">
</p><p>
 
Приведенный пример показывает, как не следует использовать рекурсию. Но заметим, что если существует быстрое итерационное решение, то тот же цикл можно реализовать с помощью рекурсивной процедуры или функции. Например:</p><p><pre>
function Fib(x1, x2, n: integer): integer;
var
  x3: integer;
begin
  if n > 1 then
  begin
    x3 := x2 + x1;
    x1 := x2;
    x2 := x3;
    Fib := Fib(x1, x2, n-1);
  end else
    Fib := x2;
end;</pre></p><p>
Любые рекурсивные процедуры и функции, содержащие всего один рекурсивный вызов самих себя, притом если он является последней выполняемой операцией в данной подпрограмме, легко заменяются итерационными циклами. Чтобы получить что-то, не имеющее простого нерекурсивного аналога, следует обратиться к процедурам и функциям, вызывающим себя два и более раз. В этом случае множество вызываемых процедур образует уже не цепочку, а целое дерево. Существуют широкие классы задач, когда вычислительный процесс должен быть организован именно таким образом. Как раз для них рекурсия будет наиболее простым и естественным способом решения.

            </p>