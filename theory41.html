<html>
    <head>
        <meta charset="utf-8">
        <title>Теория: примеры</title>
        <link rel="stylesheet" href="css/myStyle.css" type="text/css">
    </head>
    <body>
        <div id="navigation">
            <ul>
                <li><a href="theory1.html">Теория</a></li>
                <li><a href="illustration1.html">Иллюстрация</a></li>
                <li><a href="test.php">Тест</a></li>
            </ul>
        </div>
        
        <div class="sidebar">
            <ul>
                <li><a href="theory1.html">Понятие рекурсии</a></li>
                <li><a href="theory2.html">Косвенная рекурсия</a></li>
                <li><a href="theory3.html">Рекурсия и итерация</a></li>
                <li>Примеры</li>
                <ul class="ex">
                    <li><a href="theory41.html" class="special">“Индийский алгоритм” возведения в степень</a></li>
                    <li><a href="theory42.html">Ханойские башни</a></li>
                    <li><a href="theory43.html">Обход графа в глубину</a></li>
                </ul>
            </ul>
        </div>
        
        <div id="page">
            <br><h1>“Индийский алгоритм” возведения в степень</h1><br>
            <p>
               Этот алгоритм вычисления натуральной n-й (n>1) степени целого числа х выглядит совсем просто: при n=1 x<sup>n</sup>=x; при n>1 x<sup>n</sup>= x<sup>n mod 2</sup>(x<sup>n div 2</sup>)<sup>2</sup>. </p><p>
Основная цель этого алгоритма – сократить количество умножений при возведении в степень. Например, по этому алгоритму х<sup>5</sup>=х*(х<sup>2</sup>)<sup>2</sup>, т.е. достаточно трёх умножений вместо четырёх: х*х*х*х*х. Одно умножение экономится за счёт того, что х<sup>2</sup> хранится как промежуточное значение и умножается само на себя. Точно так же х<sup>10</sup>=1*(х<sup>5</sup>)<sup>2</sup>=(х<sup>5</sup>)<sup>2</sup>, что требует лишь четырёх умножений (три из них для вычисления х<sup>5</sup>) вместо девяти “лобовых”. Но здесь придётся хранить сначала х<sup>2</sup>, а потом х<sup>5</sup>. Очевидно, что вычисление х<sup>n</sup> сводится к вычислению х<sup>n div 2</sup>, запоминанию результата, возведению в квадрат и умножению его на х при нечётном n. Итак, вычисление x<sup>n</sup> описывается рекурсивной функцией:</p><p><pre>
function pow(x,n: integer): integer;
  var t: integer;
begin
  if odd(n) then t:=x else t:=1;
  if n=1 then pow:=x else pow:=t*sqr(pow(x,n div 2))
end;</pre></p><p>
Опишем зависимость глубины рекурсии вызовов функции от значения аргумента. В каждом следующем вложенном вызове значение аргумента n  меньше предыдущего значения, по крайней мере, вдвое. Поскольку при n=1 происходит возвращение из вызова, то таких уменьшений значения аргумента n не может быть больше чем log<sub>2</sub>n. Следовательно, глубина рекурсии вызова с аргументом n не превышает log<sub>2</sub>n.</p><p>
Такую глубину можно считать хорошим свойством алгоритма. При каждом выполнении вызова происходит не более одного деления, возведения в квадрат и умножения, поэтому общее количество арифметических операций не больше 3log<sub>2</sub>n. При больших значениях n это существенно меньше “лобовых” n-1 умножений. Например, при n=1000 это примерно 30.

            </p>
        </div>
        
    </body>
</html>