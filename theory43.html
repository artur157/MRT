<html>
    <head>
        <meta charset="utf-8">
        <title>Теория: примеры</title>
        <link rel="stylesheet" href="css/myStyle.css" type="text/css">
    </head>
    <body>
        <div id="navigation">
            <ul>
                <li><a href="theory1.html">Теория</a></li>
                <li><a href="illustration1.html">Иллюстрация</a></li>
                <li><a href="test.php">Тест</a></li>
            </ul>
        </div>
        
        <div class="sidebar">
            <ul>
                <li><a href="theory1.html">Понятие рекурсии</a></li>
                <li><a href="theory2.html">Косвенная рекурсия</a></li>
                <li><a href="theory3.html">Рекурсия и итерация</a></li>
                <li>Примеры</li>
                <ul class="ex">
                    <li><a href="theory41.html">“Индийский алгоритм” возведения в степень</a></li>
                    <li><a href="theory42.html">Ханойские башни</a></li>
                    <li><a href="theory43.html" class="special">Обход графа в глубину</a></li>
                </ul>
            </ul>
        </div>
        
        <div id="page">
            <br><h1>Обход графа в глубину</h1><br>
            <div class="rightfoto">
                <img src="img/DFS.png" alt="">
                <figcaption>Порядок обхода дерева в глубину</figcaption>
            </div>
            <p>
               Очень широко рекурсивный подход распространён для алгоритмов на графах, и в частности на деревьях. </p><p> 
                Рассмотрим алгоритм обхода графа в глубину. Это один из основных алгоритмов на графах.</p><p>
При поиске в глубину посещается первая вершина, затем необходимо идти вдоль ребер графа, до попадания в тупик. Вершина графа является тупиком, если все смежные с ней вершины уже посещены. После попадания в тупик нужно возвращаться назад вдоль пройденного пути, пока не будет обнаружена вершина, у которой есть еще не посещенная вершина, а затем необходимо двигаться в этом новом направлении. Процесс оказывается завершенным при возвращении в начальную вершину, причем все смежные с ней вершины уже должны быть посещены .</p><p>
Таким образом, основная идея поиска в глубину – когда возможные пути по ребрам, выходящим из вершин, разветвляются, нужно сначала полностью исследовать одну ветку и только потом переходить к другим веткам (если они останутся нерассмотренными).</p><p>
Поэтапно алгоритм поиска в глубину можно представить так:</p>
<ol>
    <li>Всем вершинам графа присваивается значение «не посещенная». Выбирается первая вершина и помечается как «посещенная».</li>
    <li>Для последней помеченной как «посещенная» вершины выбирается смежная вершина, являющаяся первой помеченной как «не посещенная», и ей присваивается значение «посещенная». Если таких вершин нет, то берется предыдущая помеченная вершина.</li>
    <li>Повторить шаг 2 до тех пор, пока все вершины не будут помечены как «посещенные».</li>
</ol>
<p>
	Представим один из способов представления подобного алгоритма:</p><p><pre>
procedure DFS(i: integer);
  var j: integer;
begin
  State[i] := 1;
  Write(i,’ ‘);
  for j:= 1 to n do
    if ((a[i][j]=1) and (State[j]=0)) then DFS(j);
end;</pre></p><p>
Также часто используется нерекурсивный алгоритм поиска в глубину. В этом случае рекурсия заменяется на стек. Как только вершина просмотрена, она помещается в стек, а использованной она становится, когда больше нет новых вершин, смежных с ней.</p><p>
Временная сложность зависит от представления графа. Если применена матрица смежности (как в рассмотренном алгоритме), то временная сложность равна O(n<sup>2</sup>), а если нематричное представление – O(n+m): рассматриваются все вершины и все ребра.

            </p>
        </div>
        
    </body>
</html>